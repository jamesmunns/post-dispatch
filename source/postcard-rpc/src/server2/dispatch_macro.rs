/// # Define Dispatch Macro
///
// ```rust,skip
// # use postcard_rpc::target_server::dispatch_macro::fake::*;
// # use postcard_rpc::{endpoint, target_server::{sender::Sender, SpawnContext}, WireHeader, define_dispatch};
// # use postcard_schema::Schema;
// # use embassy_usb_driver::{Bus, ControlPipe, EndpointIn, EndpointOut};
// # use serde::{Deserialize, Serialize};
//
// pub struct DispatchCtx;
// pub struct SpawnCtx;
//
// // This trait impl is necessary if you want to use the `spawn` variant,
// // as spawned tasks must take ownership of any context they need.
// impl SpawnContext for DispatchCtx {
//     type SpawnCtxt = SpawnCtx;
//     fn spawn_ctxt(&mut self) -> Self::SpawnCtxt {
//         SpawnCtx
//     }
// }
//
// define_dispatch2! {
//     dispatcher: Dispatcher<
//         Mutex = FakeMutex,
//         Driver = FakeDriver,
//         Context = DispatchCtx,
//     >;
//     AlphaEndpoint => async alpha_handler,
//     BetaEndpoint => async beta_handler,
//     GammaEndpoint => async gamma_handler,
//     DeltaEndpoint => blocking delta_handler,
//     EpsilonEndpoint => spawn epsilon_handler_task,
// }
//
// async fn alpha_handler(_c: &mut DispatchCtx, _h: WireHeader, _b: AReq) -> AResp {
//     todo!()
// }
//
// async fn beta_handler(_c: &mut DispatchCtx, _h: WireHeader, _b: BReq) -> BResp {
//     todo!()
// }
//
// async fn gamma_handler(_c: &mut DispatchCtx, _h: WireHeader, _b: GReq) -> GResp {
//     todo!()
// }
//
// fn delta_handler(_c: &mut DispatchCtx, _h: WireHeader, _b: DReq) -> DResp {
//     todo!()
// }
//
// #[embassy_executor::task]
// async fn epsilon_handler_task(_c: SpawnCtx, _h: WireHeader, _b: EReq, _sender: Sender<FakeMutex, FakeDriver>) {
//     todo!()
// }
// ```

#[macro_export]
macro_rules! define_dispatch2 {
    // This is the "blocking execution" arm for defining an endpoint
    (@arm blocking ($endpoint:ty) $handler:ident $context:ident $header:ident $req:ident $outputter:ident $spawn_fn:ident $spawner:ident) => {
        {
            let reply = $handler($context, $header.clone(), $req);
            if $outputter.reply::<$endpoint>($header.seq_no, &reply).await.is_err() {
                let err = $crate::standard_icd::WireError::SerFailed;
                $outputter.error($header.seq_no, err).await;
            }
        }
    };
    // This is the "async execution" arm for defining an endpoint
    (@arm async ($endpoint:ty) $handler:ident $context:ident $header:ident $req:ident $outputter:ident $spawn_fn:ident $spawner:ident) => {
        {
            let reply = $handler($context, $header.clone(), $req).await;
            if $outputter.reply::<$endpoint>($header.seq_no, &reply).await.is_err() {
                let err = $crate::standard_icd::WireError::SerFailed;
                $outputter.error($header.seq_no, err).await;
            }
        }
    };
    // This is the "spawn an embassy task" arm for defining an endpoint
    (@arm spawn ($endpoint:ty) $handler:ident $context:ident $header:ident $req:ident $outputter:ident $spawn_fn:ident $spawner:ident) => {
        {
            let context = $crate::target_server::SpawnContext::spawn_ctxt($context);
            if $spawn_fn($spawner, $handler(context, $header.clone(), $req, $outputter.clone())).is_err() {
                let err = $crate::standard_icd::WireError::FailedToSpawn;
                $outputter.error($header.seq_no, err).await;
            }
        }
    };
    // Optional trailing comma lol
    (
        dispatcher: $name:ident<Mutex = $mutex:ty, Driver = $driver:ty, Context = $context:ty,>;
        spawn_fn: $spawner:ident;
        $($endpoint:ty => $flavor:tt $handler:ident,)*
    ) => {
        define_dispatch2! {
            dispatcher: $name<Mutex = $mutex, Driver = $driver, Context = $context>;
            spawn_fn: $spawner;
            $(
                $endpoint => $flavor $handler,
            )*
        }
    };
    // This is the main entrypoint
    (
        dispatcher: $name:ident<WireTx = $wire_tx:ty, WireSpawn = $wire_spawn:ty, Context = $context:ty>;
        spawn_fn: $spawner:ident;
        $($endpoint:ty => $flavor:tt $handler:ident,)*
    ) => {
        /// This is a structure that handles dispatching, generated by the
        /// `postcard-rpc::define_dispatch2!()` macro.
        pub struct $name {
            pub context: $context,
            pub spawn: $wire_spawn,
        }

        impl $name {
            /// Create a new instance of the dispatcher
            pub fn new(
                context: $context,
                spawn: $wire_spawn,
            ) -> Self {
                $name {
                    context,
                    spawn,
                }
            }
        }

        impl $crate::server2::Dispatch2 for $name {
            type Tx = $wire_tx;

            /// Handle dispatching of a single frame
            async fn handle(
                &mut self,
                tx: &$crate::server2::Outputter<Self::Tx>,
                hdr: &$crate::WireHeader,
                body: &[u8],
            ) -> Result<(), ()> {
                const _REQ_KEYS_MUST_BE_UNIQUE: () = {
                    let keys = [$(<$endpoint as $crate::Endpoint>::REQ_KEY),*];

                    let mut i = 0;

                    while i < keys.len() {
                        let mut j = i + 1;
                        while j < keys.len() {
                            if keys[i].const_cmp(&keys[j]) {
                                panic!("Keys are not unique, there is a collision!");
                            }
                            j += 1;
                        }

                        i += 1;
                    }
                };

                let _ = _REQ_KEYS_MUST_BE_UNIQUE;

                match hdr.key {
                    $(
                        <$endpoint as $crate::Endpoint>::REQ_KEY => {
                            // Can we deserialize the request?
                            let Ok(req) = postcard::from_bytes::<<$endpoint as $crate::Endpoint>::Request>(body) else {
                                let err = $crate::standard_icd::WireError::DeserFailed;
                                tx.error(hdr.seq_no, err).await;
                                return Ok(());
                            };

                            // Store some items as named bindings, so we can use `ident` in the
                            // recursive macro expansion. Load bearing order: we borrow `context`
                            // from `dispatch` because we need `dispatch` AFTER `context`, so NLL
                            // allows this to still borrowck
                            let dispatch = self;
                            let context = &mut dispatch.context;
                            #[allow(unused)]
                            let spawninfo = &dispatch.spawn;

                            // This will expand to the right "flavor" of handler
                            define_dispatch2!(@arm $flavor ($endpoint) $handler context hdr req tx $spawner spawninfo);
                            Ok(())
                        }
                    )*
                    other => {
                        // huh! We have no idea what this key is supposed to be!
                        let err = $crate::standard_icd::WireError::UnknownKey(other.to_bytes());
                        tx.error(hdr.seq_no, err).await;
                        return Ok(());
                    },
                }
            }
        }

    }
}

/// This is a basic example that everything compiles. It is intended to exercise the macro above,
/// as well as provide impls for docs. Don't rely on any of this!
#[doc(hidden)]
#[allow(dead_code)]
#[cfg(feature = "test-utils")]
pub mod fake {
    use crate::{server2::{Outputter, WireRx, WireSpawn, WireTx}, target_server::SpawnContext};
    #[allow(unused_imports)]
    use crate::{endpoint, target_server::sender::Sender, Schema, WireHeader};
    use embassy_executor::{SpawnError, SpawnToken, Spawner};
    use serde::{Deserialize, Serialize};

    #[derive(Serialize, Deserialize, Schema)]
    pub struct AReq;
    #[derive(Serialize, Deserialize, Schema)]
    pub struct AResp;
    #[derive(Serialize, Deserialize, Schema)]
    pub struct BReq;
    #[derive(Serialize, Deserialize, Schema)]
    pub struct BResp;
    #[derive(Serialize, Deserialize, Schema)]
    pub struct GReq;
    #[derive(Serialize, Deserialize, Schema)]
    pub struct GResp;
    #[derive(Serialize, Deserialize, Schema)]
    pub struct DReq;
    #[derive(Serialize, Deserialize, Schema)]
    pub struct DResp;
    #[derive(Serialize, Deserialize, Schema)]
    pub struct EReq;
    #[derive(Serialize, Deserialize, Schema)]
    pub struct EResp;

    endpoint!(AlphaEndpoint, AReq, AResp, "alpha");
    endpoint!(BetaEndpoint, BReq, BResp, "beta");
    endpoint!(GammaEndpoint, GReq, GResp, "gamma");
    endpoint!(DeltaEndpoint, DReq, DResp, "delta");
    endpoint!(EpsilonEndpoint, EReq, EResp, "epsilon");
    #[derive(Clone)]
    pub struct FakeWireTx;
    pub struct FakeWireRx;
    #[derive(Clone)]
    pub struct FakeWireSpawn {
        spawner: Spawner,
    }

    impl WireTx for FakeWireTx {
        type Error = ();

        async fn send<T: serde::Serialize + ?Sized>(
            &self,
            _hdr: crate::WireHeader,
            _msg: &T,
        ) -> Result<(), Self::Error> {
            Ok(())
        }

        async fn send_raw(&self, _buf: &[u8]) -> Result<(), Self::Error> {
            Ok(())
        }
    }

    impl WireRx for FakeWireRx {
        type Error = ();

        async fn receive<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], Self::Error> {
            Ok(buf)
        }
    }


    impl WireSpawn for FakeWireSpawn {
        type Error = SpawnError;

        type Info = Spawner;

        fn info(&self) -> &Self::Info {
            &self.spawner
        }
    //     type Error = ();
    //     type SpawnInfo = BoxFuture;

    //     fn spawn<F: Into<Self::SpawnInfo>>(&self, fut: F) -> Result<(), Self::Error> {
    //         let x: Self::SpawnInfo = fut.into();
    //         let f = x.fut;
    //         tokio::task::spawn(f);
    //         Ok(())
    //     }
    }

    // pub struct BoxFuture {
    //     fut: Pin<Box<dyn Future<Output = Result<(), ()>> + Send + 'static>>,
    // }

    // impl<F: Future<Output = Result<(), ()>> + Send + 'static> From<F> for BoxFuture {
    //     fn from(value: F) -> Self {
    //         BoxFuture { fut: Box::pin(value) }
    //     }
    // }

    pub struct TestContext {
        pub a: u32,
        pub b: u32,
    }

    impl SpawnContext for TestContext {
        type SpawnCtxt = TestSpawnContext;

        fn spawn_ctxt(&mut self) -> Self::SpawnCtxt {
            TestSpawnContext { b: self.b }
        }
    }

    pub struct TestSpawnContext {
        b: u32,
    }

    fn embassy_spawn<Sp: WireSpawn<Info = Spawner, Error = SpawnError>, S>(sp: &Sp, fut: SpawnToken<S>) -> Result<(), Sp::Error> {
        let spawner = sp.info();
        spawner.spawn(fut)
    }

    define_dispatch2! {
        dispatcher: TestDispatcher<WireTx = FakeWireTx, WireSpawn = FakeWireSpawn, Context = TestContext>;
        spawn_fn: embassy_spawn;
        AlphaEndpoint => async test_alpha_handler,
        BetaEndpoint => async test_beta_handler,
        GammaEndpoint => async test_gamma_handler,
        DeltaEndpoint => blocking test_delta_handler,
        EpsilonEndpoint => spawn test_epsilon_handler_task,
    }

    async fn test_alpha_handler(
        _context: &mut TestContext,
        _header: WireHeader,
        _body: AReq,
    ) -> AResp {
        todo!()
    }

    async fn test_beta_handler(
        _context: &mut TestContext,
        _header: WireHeader,
        _body: BReq,
    ) -> BResp {
        todo!()
    }

    async fn test_gamma_handler(
        _context: &mut TestContext,
        _header: WireHeader,
        _body: GReq,
    ) -> GResp {
        todo!()
    }

    fn test_delta_handler(_context: &mut TestContext, _header: WireHeader, _body: DReq) -> DResp {
        todo!()
    }

    #[embassy_executor::task]
    async fn test_epsilon_handler_task(
        _context: TestSpawnContext,
        _header: WireHeader,
        _body: EReq,
        _sender: Outputter<FakeWireTx>,
    ) {
        todo!()
    }
}

#[doc(hidden)]
#[allow(dead_code)]
#[cfg(feature = "test-utils")]
pub mod fake_tokio {
    use core::{convert::Infallible, future::Future};

    use crate::{server2::{Outputter, WireRx, WireSpawn, WireTx}, target_server::SpawnContext};
    #[allow(unused_imports)]
    use crate::{endpoint, target_server::sender::Sender, Schema, WireHeader};
    use embassy_executor::{SpawnError, SpawnToken, Spawner};
    use serde::{Deserialize, Serialize};

    #[derive(Serialize, Deserialize, Schema)]
    pub struct AReq;
    #[derive(Serialize, Deserialize, Schema)]
    pub struct AResp;
    #[derive(Serialize, Deserialize, Schema)]
    pub struct BReq;
    #[derive(Serialize, Deserialize, Schema)]
    pub struct BResp;
    #[derive(Serialize, Deserialize, Schema)]
    pub struct GReq;
    #[derive(Serialize, Deserialize, Schema)]
    pub struct GResp;
    #[derive(Serialize, Deserialize, Schema)]
    pub struct DReq;
    #[derive(Serialize, Deserialize, Schema)]
    pub struct DResp;
    #[derive(Serialize, Deserialize, Schema)]
    pub struct EReq;
    #[derive(Serialize, Deserialize, Schema)]
    pub struct EResp;

    endpoint!(AlphaEndpoint, AReq, AResp, "alpha");
    endpoint!(BetaEndpoint, BReq, BResp, "beta");
    endpoint!(GammaEndpoint, GReq, GResp, "gamma");
    endpoint!(DeltaEndpoint, DReq, DResp, "delta");
    endpoint!(EpsilonEndpoint, EReq, EResp, "epsilon");
    #[derive(Clone)]
    pub struct FakeWireTx;
    pub struct FakeWireRx;
    #[derive(Clone)]
    pub struct FakeWireSpawn;

    impl WireTx for FakeWireTx {
        type Error = ();

        async fn send<T: serde::Serialize + ?Sized>(
            &self,
            _hdr: crate::WireHeader,
            _msg: &T,
        ) -> Result<(), Self::Error> {
            Ok(())
        }

        async fn send_raw(&self, _buf: &[u8]) -> Result<(), Self::Error> {
            Ok(())
        }
    }

    impl WireRx for FakeWireRx {
        type Error = ();

        async fn receive<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], Self::Error> {
            Ok(buf)
        }
    }


    impl WireSpawn for FakeWireSpawn {
        type Error = Infallible;

        type Info = ();

        fn info(&self) -> &Self::Info {
            &()
        }
    //     type Error = ();
    //     type SpawnInfo = BoxFuture;

    //     fn spawn<F: Into<Self::SpawnInfo>>(&self, fut: F) -> Result<(), Self::Error> {
    //         let x: Self::SpawnInfo = fut.into();
    //         let f = x.fut;
    //         tokio::task::spawn(f);
    //         Ok(())
    //     }
    }

    // pub struct BoxFuture {
    //     fut: Pin<Box<dyn Future<Output = Result<(), ()>> + Send + 'static>>,
    // }

    // impl<F: Future<Output = Result<(), ()>> + Send + 'static> From<F> for BoxFuture {
    //     fn from(value: F) -> Self {
    //         BoxFuture { fut: Box::pin(value) }
    //     }
    // }

    pub struct TestContext {
        pub a: u32,
        pub b: u32,
    }

    impl SpawnContext for TestContext {
        type SpawnCtxt = TestSpawnContext;

        fn spawn_ctxt(&mut self) -> Self::SpawnCtxt {
            TestSpawnContext { b: self.b }
        }
    }

    pub struct TestSpawnContext {
        b: u32,
    }

    fn tokio_spawn<Sp: WireSpawn<Info = (), Error = Infallible>, F: Future<Output = ()> + Send + 'static>(_sp: &Sp, fut: F) -> Result<(), Sp::Error> {
        tokio::task::spawn(fut);
        Ok(())
    }

    define_dispatch2! {
        dispatcher: TestDispatcher<WireTx = FakeWireTx, WireSpawn = FakeWireSpawn, Context = TestContext>;
        spawn_fn: tokio_spawn;
        AlphaEndpoint => async test_alpha_handler,
        BetaEndpoint => async test_beta_handler,
        GammaEndpoint => async test_gamma_handler,
        DeltaEndpoint => blocking test_delta_handler,
        EpsilonEndpoint => spawn test_epsilon_handler_task,
    }

    async fn test_alpha_handler(
        _context: &mut TestContext,
        _header: WireHeader,
        _body: AReq,
    ) -> AResp {
        todo!()
    }

    async fn test_beta_handler(
        _context: &mut TestContext,
        _header: WireHeader,
        _body: BReq,
    ) -> BResp {
        todo!()
    }

    async fn test_gamma_handler(
        _context: &mut TestContext,
        _header: WireHeader,
        _body: GReq,
    ) -> GResp {
        todo!()
    }

    fn test_delta_handler(_context: &mut TestContext, _header: WireHeader, _body: DReq) -> DResp {
        todo!()
    }

    async fn test_epsilon_handler_task(
        _context: TestSpawnContext,
        _header: WireHeader,
        _body: EReq,
        _sender: Outputter<FakeWireTx>,
    ) {
        todo!()
    }
}
